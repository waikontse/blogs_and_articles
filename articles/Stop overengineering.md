Have you ever wondered whether you should keep developing further the code you are working on?
The questions that forms in your head of future scenarios where your code might not be enough?
Welcome to overengineering. But what does it actually mean to overengineer?
(inset quote here) [from webster/wikipedia]

From the definition above, it feels like when we think of future fail scenarios we notch ourselves to start overengineering. 
In the rest of the article you will find where overengineering can happen, guidelines to prevent overengineering and what you can do instead.
You might be thinking now, what's the difference between preventing and 'do this instead of' overengineering. 
There is a difference here between preventing and what we can pro-actively do.
Preventing is stopping us from overengineering in the first place, and pro-actively doing something to prepare us for future enhancements.

# On what levels can we over-engineer?
I've chosen to use the C4 model as proprosed by (c4 author) 
I find that it gives a good model of where overengineering might and can happen.
The C4 model describes 4 views one can have on a sytem.
1. system [C]ontext
2. [C]ontainers
3. [C]omponents
4. [C]ode


## How to prevent overengineering

## What to do instead

# Resources
1. What is overengineering?
2. What is the meaning of overengineering?
3. How can we detect overengineering?
4. How can we manage technical debt?

# Terms to use
1. impact of change
2. technical debt
3. hexagonal architecture
4. DDD (Domain Driven Design)
5. SOLID
6. Layering -> maybe hexagonal architecture
7. feature creep
8. reduce coupling
9. testing
10. increase flexibility
11. 


# inspirations
[[202201060833 Overengineering resources]]